type: edu
files:
- name: src/Application.kt
  visible: true
  text: |-
    package hotkitchen

    import io.ktor.application.*

    fun main(args: Array<String>): Unit = io.ktor.server.netty.EngineMain.main(args)

    fun Application.module(testing: Boolean = false) {}
  learner_created: false
- name: build.gradle
  visible: true
  text: |-
    buildscript {
        repositories {
            mavenCentral()
        }
        dependencies {
            classpath "org.jetbrains.kotlin:kotlin-serialization:1.6.21"
        }
    }
    def ktor_version = "1.6.7"

    apply plugin: 'java'
    apply plugin: 'org.jetbrains.kotlin.jvm'
    apply plugin: 'kotlin'
    apply plugin: 'kotlinx-serialization'

    repositories {
        mavenCentral()
    }


    sourceSets.main.resources.srcDirs = ["src/resources"]

    dependencies {
        implementation "org.jetbrains.kotlin:kotlin-stdlib"
        implementation "io.ktor:ktor-server-core:$ktor_version"
        implementation "io.ktor:ktor-server-netty:$ktor_version"
        implementation("ch.qos.logback:logback-classic:1.2.10")

        implementation "io.ktor:ktor-auth:$ktor_version"
        implementation "io.ktor:ktor-auth-jwt:$ktor_version"

        implementation "io.ktor:ktor-serialization:$ktor_version"
        implementation('org.jetbrains.exposed:exposed-core:0.37.3')
        implementation('org.jetbrains.exposed:exposed-dao:0.37.3')
        implementation('org.jetbrains.exposed:exposed-jdbc:0.37.3')
        implementation('com.zaxxer:HikariCP:5.0.1')
        implementation("org.postgresql:postgresql:42.3.2")
    }
  learner_created: false
- name: test/HotKitchenTest.kt
  visible: false
  text: |-
    import com.typesafe.config.ConfigFactory
    import io.ktor.config.*
    import io.ktor.http.*
    import io.ktor.server.testing.*
    import kotlinx.serialization.Serializable
    import kotlinx.serialization.decodeFromString
    import kotlinx.serialization.encodeToString
    import kotlinx.serialization.json.Json
    import org.hyperskill.hstest.dynamic.DynamicTest
    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult

    class HotKitchenTest : StageTest<Any>() {

        @Serializable
        private data class Credentials(var email: String, var userType: String, var password: String)

        @Serializable
        private data class Token(val token: String)

        @Serializable
        data class Meal(
            val mealId: Int,
            val title: String,
            val price: Float,
            val imageUrl: String,
            val categoryIds: List<Int>
        )

        @Serializable
        data class Category(
            val categoryId: Int,
            val title: String,
            val description: String
        )

        private val time = System.currentTimeMillis()
        private val jwtRegex = """^[a-zA-Z0-9]+?\.[a-zA-Z0-9]+?\..+""".toRegex()
        private val accessDenied = """{"status":"Access denied"}"""
        private val currentCredentialsClient = Credentials("$time@client.com", "client", "password$time")
        private val currentCredentialsStaff = Credentials("$time@staff.com", "staff", "password$time")
        private val currentMeal = Meal(
            time.toInt(),
            "$time title",
            (time.toInt() % 100).toFloat(),
            "image $time url",
            listOf((0..10).random(), (0..10).random(), (0..10).random())
        )
        private val currentCategory = Category(
            time.toInt(),
            "$time TITLE",
            "Awesome $time description"
        )
        private lateinit var signInTokenClient: String
        private lateinit var signInTokenStaff: String


        @DynamicTest(order = 1)
        fun getSignInJWTToken(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/signup") {
                setBody(Json.encodeToString(currentCredentialsClient))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                try {
                    val principal = Json.decodeFromString<Token>(response.content ?: "")
                    signInTokenClient = principal.token
                    if (!signInTokenClient.matches(jwtRegex) || signInTokenClient.contains(currentCredentialsClient.email))
                        return@withApplication CheckResult.wrong("Invalid JWT token")
                } catch (e: Exception) {
                    return@withApplication CheckResult.wrong("Cannot get token form /signin request")
                }
            }
            with(handleRequest(HttpMethod.Post, "/signup") {
                setBody(Json.encodeToString(currentCredentialsStaff))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                try {
                    val principal = Json.decodeFromString<Token>(response.content ?: "")
                    signInTokenStaff = principal.token
                    if (!signInTokenStaff.matches(jwtRegex) || signInTokenStaff.contains(currentCredentialsStaff.email))
                        return@withApplication CheckResult.wrong("Invalid JWT token")
                } catch (e: Exception) {
                    return@withApplication CheckResult.wrong("Cannot get token form /signin request")
                }
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 2)
        fun correctValidation(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/validate") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                if (response.status() != HttpStatusCode.OK || response.content != "Hello, ${currentCredentialsClient.userType} ${currentCredentialsClient.email}") return@withApplication CheckResult.wrong(
                    "Token validation with signin token failed.\nStatus code should be \"200 OK\"\nMessage should be \"Hello, ${currentCredentialsClient.userType} ${currentCredentialsClient.email}\""
                )
            }
            with(handleRequest(HttpMethod.Get, "/validate") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
            }) {
                if (response.status() != HttpStatusCode.OK || response.content != "Hello, ${currentCredentialsStaff.userType} ${currentCredentialsStaff.email}") return@withApplication CheckResult.wrong(
                    "Token validation with signin token failed.\nStatus code should be \"200 OK\"\nMessage should be \"Hello, ${currentCredentialsStaff.userType} ${currentCredentialsStaff.email}\""
                )
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 3)
        fun accessDeniedAdditionMeal(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/meals") {
                setBody(Json.encodeToString(currentMeal))
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.Forbidden || response.content != accessDenied)
                    return@withApplication CheckResult.wrong("Only staff can add meal. Wrong response or status code")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 4)
        fun accessDeniedAdditionCategory(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/categories") {
                setBody(Json.encodeToString(currentCategory))
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.Forbidden || response.content != accessDenied)
                    return@withApplication CheckResult.wrong("Only staff can add category. Wrong response or status code")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 5)
        fun successAdditionMeal(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/meals") {
                setBody(Json.encodeToString(currentMeal))
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("The meal was not added. Wrong status code.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 6)
        fun failedAdditionMeal(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/meals") {
                setBody(Json.encodeToString(currentMeal))
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.BadRequest)
                    return@withApplication CheckResult.wrong("The meal was added twice. Wrong status code.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 7)
        fun successAdditionCategory(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/categories") {
                setBody(Json.encodeToString(currentCategory))
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("The category was not added. Wrong status code.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 8)
        fun failedAdditionCategory(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/categories") {
                setBody(Json.encodeToString(currentCategory))
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenStaff")
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.BadRequest)
                    return@withApplication CheckResult.wrong("The category was added twice. Wrong status code.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 9)
        fun getMealById(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/meals?id=${currentMeal.mealId}") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                if (response.content != Json.encodeToString(currentMeal))
                    return@withApplication CheckResult.wrong("Wrong meal by id.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 10)
        fun getCategoryById(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/categories?id=${currentCategory.categoryId}") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                if (response.content != Json.encodeToString(currentCategory))
                    return@withApplication CheckResult.wrong("Wrong category by id.")
            }
            return@withApplication CheckResult.correct()
        }


        @DynamicTest(order = 11)
        fun getMeals(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/meals") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                val meals: List<Meal> = Json.decodeFromString(response.content ?: "")
                var flag = true
                for (meal in meals) {
                    if (meal.mealId == currentMeal.mealId) {
                        flag = false
                        break
                    }
                }
                if (flag) return@withApplication CheckResult.wrong("Wrong meals list. The newly added meal is missing.")
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Wrong status code in /meals")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 12)
        fun getCategories(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/categories") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInTokenClient")
            }) {
                val categories: List<Category> = Json.decodeFromString(response.content ?: "")
                var flag = true
                for (category in categories) {
                    if (category.categoryId == currentCategory.categoryId) {
                        flag = false
                        break
                    }
                }
                if (flag)
                    return@withApplication CheckResult.wrong("Wrong categories list. The newly added category is missing.")
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Wrong status code in /categories")
            }
            return@withApplication CheckResult.correct()
        }

    }
  learner_created: false
- name: test/SimpleTest.kt
  visible: true
  text: |-
    import com.typesafe.config.ConfigFactory
    import io.ktor.config.*
    import io.ktor.http.*
    import io.ktor.server.testing.*
    import kotlinx.serialization.Serializable
    import kotlinx.serialization.decodeFromString
    import kotlinx.serialization.encodeToString
    import kotlinx.serialization.json.Json
    import org.hyperskill.hstest.dynamic.DynamicTest
    import org.hyperskill.hstest.stage.StageTest
    import org.hyperskill.hstest.testcase.CheckResult

    class SimpleTest : StageTest<Any>() {

        @Serializable
        private data class Credentials(var email: String, var userType: String, var password: String)

        @Serializable
        private data class User(
            val name: String, val userType: String, val phone: String, val email: String, val address: String
        )

        private fun User.isEquals(user: User) =
            name == user.name && userType == user.userType && phone == user.phone && email == user.email && address == user.address


        @Serializable
        private data class Token(val token: String)

        private val time = System.currentTimeMillis().toString()
        private val jwtRegex = """^[a-zA-Z0-9]+?\.[a-zA-Z0-9]+?\..+""".toRegex()
        private val currentCredentials = Credentials("$time@mail.com", "client", "password$time")
        private var currentUser = User(time + "name", "client", "+79999999999", currentCredentials.email, time + "address")
        private lateinit var signInToken: String


        @DynamicTest(order = 1)
        fun getSignInJWTToken(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/signup") {
                setBody(Json.encodeToString(currentCredentials))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                try {
                    val principal = Json.decodeFromString<Token>(response.content ?: "")
                    signInToken = principal.token
                    if (!signInToken.matches(jwtRegex) || signInToken.contains(currentCredentials.email)) return@withApplication CheckResult.wrong(
                        "Invalid JWT token"
                    )
                } catch (e: Exception) {
                    return@withApplication CheckResult.wrong("Cannot get token form /signin request")
                }
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 2)
        fun correctValidation(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/validate") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInToken")
            }) {
                if (response.status() != HttpStatusCode.OK || response.content != "Hello, ${currentCredentials.userType} ${currentCredentials.email}") return@withApplication CheckResult.wrong(
                    "Token validation with signin token failed.\nStatus code should be \"200 OK\"\nMessage should be \"Hello, ${currentCredentials.userType} ${currentCredentials.email}\""
                )
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 3)
        fun getNonExistentUser(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/me") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInToken")
            }) {
                if (response.status() != HttpStatusCode.BadRequest) return@withApplication CheckResult.wrong("Status code for a getting non-existent user should be \"400 Bad Request\"")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 4)
        fun createUser(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Put, "/me") {
                setBody(Json.encodeToString(currentUser))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
                addHeader(HttpHeaders.Authorization, "Bearer $signInToken")
            }) {
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Cannot add user by put method")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 5)
        fun getExistentUser(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/me") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInToken")
            }) {
                val user = Json.decodeFromString<User>(response.content ?: "")
                if (!user.isEquals(currentUser)) return@withApplication CheckResult.wrong("Get method responded with different user information.")
                if (response.status() != HttpStatusCode.OK) return@withApplication CheckResult.wrong("Status code for a getting existent user should be \"200 OK\"")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 6)
        fun putDifferentEmail(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Put, "/me") {
                val newUser = currentUser.copy(email = "different@mail.com")
                setBody(Json.encodeToString(newUser))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
                addHeader(HttpHeaders.Authorization, "Bearer $signInToken")
            }) {
                if (response.status() != HttpStatusCode.BadRequest)
                    return@withApplication CheckResult.wrong("You can not change the user's email! Wrong status code.")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 7)
        fun updateCurrentUser(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Put, "/me") {
                currentUser = currentUser.copy(name = "newName$time", userType = "newType", address = "newAddress$time")
                setBody(Json.encodeToString(currentUser))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
                addHeader(HttpHeaders.Authorization, "Bearer $signInToken")
            }) {
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Cannot update user information by put method")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 8)
        fun getNewExistentUser(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/me") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInToken")
            }) {
                val user = Json.decodeFromString<User>(response.content ?: "")
                if (!user.isEquals(currentUser)) return@withApplication CheckResult.wrong("Get method responded with different user information after updating user info.")
                if (response.status() != HttpStatusCode.OK) return@withApplication CheckResult.wrong("Status code for a getting existent user should be \"200 OK\"")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 9)
        fun deleteExistentUser(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Delete, "/me") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInToken")
            }) {
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Status code for a deleting existent user should be \"200 OK\"")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 10)
        fun deleteNonExistentUser(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Delete, "/me") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInToken")
            }) {
                if (response.status() != HttpStatusCode.BadRequest)
                    return@withApplication CheckResult.wrong("Status code for a deleting non-existent user should be \"400 Bad Request\"")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 11)
        fun getDeletedUser(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Get, "/me") {
                addHeader(HttpHeaders.Authorization, "Bearer $signInToken")
            }) {
                if (response.status() != HttpStatusCode.BadRequest)
                    return@withApplication CheckResult.wrong("Status code for a getting deleted user should be \"400 Bad Request\"")
            }
            return@withApplication CheckResult.correct()
        }

        @DynamicTest(order = 12)
        fun checkDeletedCredentials(): CheckResult = withApplication(createTestEnvironment {
            config = HoconApplicationConfig(ConfigFactory.load("application.conf"))
        }) {
            with(handleRequest(HttpMethod.Post, "/signup") {
                setBody(Json.encodeToString(currentCredentials))
                addHeader(HttpHeaders.ContentType, ContentType.Application.Json.toString())
            }) {
                if (response.status() != HttpStatusCode.OK)
                    return@withApplication CheckResult.wrong("Unable to signin after deleting user information. Did you forget to delete user credentials?")
            }
            return@withApplication CheckResult.correct()
        }
    }
  learner_created: false
- name: src/database/UserTable.kt
  visible: true
  text: |-
    package hotkitchen.database

    import org.jetbrains.exposed.dao.id.IntIdTable
    import org.jetbrains.exposed.sql.Column

    object UserTable : IntIdTable() {
        val email: Column<String> = text("email")
        val userType: Column<String> = text("userType")
        val password: Column<String> = text("password")
        val phone: Column<String?> = text("phone").nullable()
        val address: Column<String?> = text("address").nullable()
        val name: Column<String?> = text("name").nullable()
    }
  learner_created: true
- name: src/data/ResponseStatus.kt
  visible: true
  text: |-
    package hotkitchen.data

    import kotlinx.serialization.Serializable

    @Serializable
    data class ResponseStatus(
        val status: String
    )
  learner_created: true
- name: src/utils/TokenUtils.kt
  visible: true
  text: |+
    package hotkitchen.utils

    import com.auth0.jwt.JWT
    import com.auth0.jwt.algorithms.Algorithm
    import com.typesafe.config.ConfigFactory
    import hotkitchen.data.User
    import io.ktor.config.*
    import java.util.*

    //val secret = environment.config.property("jwt.secret").getString()

    val secret = HoconApplicationConfig(ConfigFactory.load()).property("jwt.secret").getString()
    fun generateToken(user: User): String = JWT.create()
            .withClaim("email", user.email)
            .withClaim("userType", user.userType)
            .withExpiresAt(Date(System.currentTimeMillis() + 60000))
            .sign(Algorithm.HMAC256(secret))

  learner_created: true
- name: src/database/DatabaseFactory.kt
  visible: true
  text: |-
    package hotkitchen.database

    import com.typesafe.config.ConfigFactory
    import com.zaxxer.hikari.HikariConfig
    import com.zaxxer.hikari.HikariDataSource
    import io.ktor.application.*
    import io.ktor.config.*
    import org.jetbrains.exposed.sql.Database
    import org.jetbrains.exposed.sql.SchemaUtils
    import org.jetbrains.exposed.sql.StdOutSqlLogger
    import org.jetbrains.exposed.sql.addLogger
    import org.jetbrains.exposed.sql.transactions.transaction

    object DatabaseFactory {

        private val appConfig = HoconApplicationConfig(ConfigFactory.load())
        private val driverClassName = appConfig.property("storage.driverClassName").getString()
        private val dbUrl = appConfig.property("storage.jdbcURL").getString()
        private val dbUser = appConfig.property("storage.username").getString()
        private val dbUserPassword = appConfig.property("storage.password").getString()

        fun init() {
            Database.connect(hikari())
        }

        private fun hikari(): HikariDataSource {
            val config = HikariConfig()
            config.driverClassName = driverClassName
            config.username = dbUser
            config.jdbcUrl = dbUrl
            config.password = dbUserPassword
            config.maximumPoolSize = 3
            config.isAutoCommit = false
            config.transactionIsolation = "TRANSACTION_REPEATABLE_READ"
            config.validate()
            return HikariDataSource(config)
        }
    }

    fun Application.configureDatabase() {
        DatabaseFactory.init()
        transaction {
           SchemaUtils.create(UserTable)
        }
        transaction {
            addLogger(StdOutSqlLogger)
        }
    }
  learner_created: true
- name: src/data/User.kt
  visible: true
  text: |
    package hotkitchen.data

    import kotlinx.serialization.Serializable

    @Serializable
    data class User(
        val email: String,
        val userType: String,
        val password: String
    )
  learner_created: true
- name: src/data/UserInfo.kt
  visible: true
  text: |-
    package hotkitchen.data

    import kotlinx.serialization.Serializable

    @Serializable
    data class UserInfo (
        val name: String?,
        val userType: String,
        val phone: String?,
        val email: String,
        val address: String?
    )
  learner_created: true
- name: src/data/ResponseToken.kt
  visible: true
  text: |
    package hotkitchen.data

    import kotlinx.serialization.Serializable

    @Serializable
    data class ResponseToken(
        val token: String
    )
  learner_created: true
- name: src/utils/AuthUtils.kt
  visible: true
  text: |-
    package hotkitchen.utils

    class ForbiddenException(message: String?) : Exception(message)
    class BadRequestException() : Exception()
    val emailRegex = """(^[a-zA-Z0-9_+-.]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+${'$'})"""
    fun checkEmail(email: String) {
        if (!email.matches(emailRegex.toRegex()))
            throw ForbiddenException("Invalid email")
    }

    fun checkPassword(password: String){
        if (password.length < 6
                || password.all { char -> char.isDigit() }
                || password.all { char ->  char.isLetter() }
                || password.all { char -> !char.isLetter() && !char.isDigit() })
            throw ForbiddenException("Invalid password")
    }
  learner_created: true
- name: src/routing/Routing.kt
  visible: true
  text: |-
    package hotkitchen.routing

    import hotkitchen.data.*
    import hotkitchen.database.DatabaseController
    import hotkitchen.utils.BadRequestException
    import hotkitchen.utils.checkEmail
    import hotkitchen.utils.checkPassword
    import hotkitchen.utils.generateToken
    import io.ktor.application.*
    import io.ktor.auth.*
    import io.ktor.auth.jwt.*
    import io.ktor.http.*
    import io.ktor.request.*
    import io.ktor.response.*
    import io.ktor.routing.*
    import kotlinx.serialization.encodeToString
    import kotlinx.serialization.json.Json

    fun Application.configureRouting() {
        routing {
            get("/main"){
                call.respondText("Hello World!")
            }
            post("/signup") {
                println("dignup1")
                val user = call.receive<User>()
                checkEmail(user.email)
                checkPassword(user.password)
                if (DatabaseController.getUserByEmail(user.email) == null) {
                    DatabaseController.saveUser(user)
                    call.respond(HttpStatusCode.OK, ResponseToken(generateToken(user)))
                } else {
                    call.respond(HttpStatusCode.Forbidden, ResponseStatus("User already exists"))
                }

            }

            post("/signin") {
                val signInUser = call.receive<SignIn>()
                val user = DatabaseController.getUserByEmail(signInUser.email)
                if (user != null && user.password == signInUser.password) {
                    call.respond(HttpStatusCode.OK, ResponseToken(generateToken(user)))
                } else {
                    call.respond(HttpStatusCode.Forbidden, ResponseStatus("Invalid email or password"))
                }
            }

            authenticate {
                get("/validate") {
                    try {
                        val principal = call.principal<JWTPrincipal>()
                        val email = principal!!.payload.getClaim("email").asString()
                        val userType = principal.payload.getClaim("userType").asString()
                        //call.respond(HttpStatusCode.OK)
                        call.respondText("Hello, $userType $email")
                    } catch (e: Exception) {
                        call.respond(HttpStatusCode.Unauthorized)
                    }
                }

                get("/me") {
                    try {
                        println("1")
                        val principal = call.principal<JWTPrincipal>()
                        val email = principal!!.payload.getClaim("email").asString()
                        val user = DatabaseController.getUserInfoByEmail(email)
                        if (user != null) {
                            if (user.name.isNullOrBlank() || user.phone.isNullOrBlank() || user.address.isNullOrBlank() ) {
                                call.respond(HttpStatusCode.BadRequest)
                            } else {
                                call.respondText(Json.encodeToString(user), ContentType.Application.Json)
                            }
                        } else {
                            call.respond(HttpStatusCode.BadRequest)
                        }
                    } catch (e: Exception) {
                        call.respond(HttpStatusCode.BadRequest)
                    }
                }

                put("/me") {
                    try {
                        val principal = call.principal<JWTPrincipal>()
                        val email = principal!!.payload.getClaim("email").asString()
                        val user = DatabaseController.getUserInfoByEmail(email)
                        val userInfo = call.receive<UserInfo>()

                        if (user != null) {
                            DatabaseController.updateUserByEmail(email, userInfo)
                        } else {
                            DatabaseController.saveUser(userInfo)
                        }
                        call.respond(HttpStatusCode.OK)
                    } catch (e: Exception) {
                        call.respond(HttpStatusCode.BadRequest)
                    }
                }
                delete("/me") {
                    try {
                        val principal = call.principal<JWTPrincipal>()
                        val email = principal!!.payload.getClaim("email").asString()

                        if (!DatabaseController.deleteUserByEmail(email))
                            throw BadRequestException()
                        call.respond(HttpStatusCode.OK)
                    } catch (_: Exception) {
                        call.respond(HttpStatusCode.BadRequest)
                    }

                }
            }

        }
    }
  learner_created: true
- name: src/data/SignIn.kt
  visible: true
  text: |
    package hotkitchen.data

    import kotlinx.serialization.Serializable

    @Serializable
    data class SignIn(
        val email: String,
        val password: String
    )
  learner_created: true
- name: src/Test.http
  visible: true
  text: |
    POST http://localhost:28852/signup
    Content-Type: application/json

    {
        "email":"t2333yry@mail.ru",
        "userType":"stuff",
        "password": ""
    }
  learner_created: true
- name: src/database/DatabaseController.kt
  visible: true
  text: |-
    package hotkitchen.database

    import hotkitchen.data.User
    import hotkitchen.data.UserInfo
    import hotkitchen.utils.BadRequestException
    import org.jetbrains.exposed.sql.deleteWhere
    import org.jetbrains.exposed.sql.insert
    import org.jetbrains.exposed.sql.select
    import org.jetbrains.exposed.sql.transactions.transaction
    import org.jetbrains.exposed.sql.update

    object DatabaseController {

        suspend fun getUserByEmail(email: String) = transaction {
            val query = UserTable.select { UserTable.email eq email }
            query.mapNotNull {
                User(
                    email = it[UserTable.email],
                    password = it[UserTable.password],
                    userType = it[UserTable.userType]
                )
            }.singleOrNull()
        }

        suspend fun saveUser(user: UserInfo) = transaction {
            UserTable.insert {
                it[email] = user.email
                it[userType] = user.userType
                it[address] = user.address
                it[phone] = user.phone
                it[name] = user.name
            }
        }

        suspend fun saveUser(user: User) = transaction {
            UserTable.insert {
                it[email] = user.email
                it[password] = user.password
                it[userType] = user.userType
            }
        }

        suspend fun getUserInfoByEmail(email: String) : UserInfo? = transaction {
            val query = UserTable.select { UserTable.email eq email }
            println ("aaaaaaa")
            query.mapNotNull {
                UserInfo(
                    name = it[UserTable.name],
                    userType = it[UserTable.userType],
                    phone = it[UserTable.phone],
                    email = it[UserTable.email],
                    address = it[UserTable.address]
                )
            }.singleOrNull()
        }


        suspend fun updateUserByEmail(email: String, user: UserInfo) = transaction {
            if (email != user.email)
                throw BadRequestException()

            UserTable.update({ UserTable.email eq email }) {
                it[name] = user.name
                it[address] = user.address
                it[userType] = user.userType
                it[phone] = user.phone
                it[UserTable.email] = user.email
            }
        }

        suspend fun deleteUserByEmail(email: String): Boolean = transaction {
            UserTable.deleteWhere { UserTable.email eq email } > 0
        }
    }
  learner_created: true
- name: src/resources/application.conf
  visible: true
  text: |-
    ktor {
        deployment {
            port = 28888
        }
        application {
            modules = [hotkitchen.ApplicationKt.module]
        }
    }
  learner_created: false
- name: src/database/MealTable.kt
  visible: true
  learner_created: true
- name: src/database/CategoryTable.kt
  visible: true
  learner_created: true
- name: src/data/Meal.kt
  visible: true
  learner_created: true
- name: src/data/Category.kt
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/22606#comment
status: Unchecked
record: -1
